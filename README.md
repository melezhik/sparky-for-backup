# sparky-for-backup

# HLD

![hld](images/HLD.png)

Архитектурная схема

- на всех нодах развернуты sparky агенты которые с переодичностью настраивают и выполняют бэкапы

- агенты также гарантируют изначальную настройку borg репозиториев

- у сервиса требующего бэкап может быть кастомная логика создания бэкапа ( например для сервиса Postgresql сначала бэкап создается через pg_dump и потом направляется в borg репозиторий )

- агенты отправляют данные ( в различном формате ) о бэкапах в sparky оркестратор ( по https протоколу ), оркестратор обрабатывает полученные данные с нод и агрегирует их ввиде различных отчетов, данные также могут перенаправлятся в web консоль exioma для последующего просмотра пользователем, также отчеты можно напрямую смотреть через UI оркестратора

- агенты также настраивают/отслылают метрики бэкапипования в развернутый внешний прометеус для последующего мониторинга

- при необходимости бэкапы могут быть запущеные в ручном режиме ( например в случае разовых сбоев ) , для этого используется sparky окрестартор с которым агенты взаимодейтсвуют в  режиме pull через http очередь

- конфигурации бэкпов и добавление новых сервсисов в бэкапы происходит посредством запуска ansible плейбуков (бандлов?) через web консоль exioma, в качестве альтернативы можно рассмотреть стягивание обновленных конфигурации на агентах через git (sparky агенты поддерживают это из коробки)

- при необходимости можно запускать распаковку (extract) бэкапов из borg репозиториве посредством запусках тех же ансибл бандлов или через интерфейс Sparky оркестратора

- ssh ключи для доступа к borп репозитариям добавляются через механизм ansible бандлов запущенных на нодах с репозиториями, альтернативно можно делать ту же самую операцию через Sparky оркестратор - что может быть удобно - когда ключи ротейтятся прямо на агентах локально и агенты отправляют свои обновленные public ключи в  оркестратор и оркестратор обновляет их на нодах с борг репозитарями - в этом случае мы минимизируем сетевой трафик ( по сравнению со схемой через ансибл ) и делаем решение более секьюрным ( private части ключей не гоняются по сети )
  

Security и сетевая схема

В данной схеме ноды со sparky агентами недоступы из вне, все взаимодействие с оркестратором происходит в pull режиме по http/https, с  аутентефикацией ( SPARKY_API_TOKEN ) -  то есть эта схема более безопасная по сравнению с тем когда мы обновляем конифигурации и запускаем бэкапы через ансибл по ssh в push режиме (все ноды становятся доступными по ssh). Также она более масштабируемая (с ростом кол-ва нод) - так как все операции происходят не в одном узком месте (ansible contole plane) - а в распределенном режиме на нодах, независимо и статусы отсылаются в орекстратор

Если нужен реверсивный флоу когда команды шлются от оркестртора (например при manual backup-ах) то с точки зрения потока данных это так же обеспечивается через pull модель - когда агенты постоянно опрашивают очередь оркестратора ( раз в несколько минут ) и получают новые команды
